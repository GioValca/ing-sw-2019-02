LOGICA DI FUNZIONAMENTO DEL CLIENT:

Posso lanciarlo e chiedere da dentro la shell in esecuzione di selezionare il tipo di connessione e in base alla scelta lanciare il processo giusto.

TODO:

	inizio con l'implementzione della parte di RMI che abbiamo già lato server

	capire cosa fare con gli observer (e come farli andare in modo condiviso sulla rete)

Mettere giu uno use case dell'inizio della partita pensando alla gestione dei turni e alla gestione della sala di attesa.


-----------------------------------------------------------------------------------------------------------------------------------

GIRO DA FARE QUANDO SI AGGIUNGE UN METODO DI MATCH CONTROLLER (CE NE SONO ANCORA UN PO DA AGGIUNGERE PER LA GESTIONE DELLA PARTITA)

    RMI

1. Aggiungere metodo a classe MatchController (SERVER)
2. Aggiungere il metodo a RemoteObjectRMI (SERVER)
3. Aggiungere il metodo a InterfaceRemoteObjectRMI (SERVER)

4. Aggiungere il metodo a RemoteController (abstract class in CLIENT)
5. Aggiungere il metodo a RemoteControllerRMI (CLIENT)

    SOCKET

GIRO DA SEGUIRE: TBD (TO BE DETERMINED)


-----------------------------------------------------------------------------------------------------------------------------------

23 MAGGIO 2019:

Gestione della coda di attesa in ingresso (pre partita):

	//TODO:
	Una volta che 3 giocatori si sono connessi: dovrebbe partire un timer di N secondi che aspetta altri eventuali giocatori (fino ad un max di 5)
	Scaduto il timer oppure raggiunti i 5 giocatori connessi la partita deve iniziare.
	Controllo sulla username, se si è gia connesso e disconnesso devo essere ingrado di ricollegare il client al giocatore corretto

	//GIA IMPLEMENTATO, FUNIZONANTE:
	un giocatore quando si connette al server e inserisce la username viene aggiunto ai players sul server
	se è il primo giocatore a connettersi gli viene chiesto che mappa vuole generare
	in seguito il client va in attesa che si connettano abbastanza giocatori andando a controllare il numero di giocatori connessi lato server

Gestione dell'uscita di un player dalla partita (hard quit, chiusura della app)

	class ExitThread extends Thread {

	         public void run() {
	             // code to perform on exit goes here
	         }
	     }

	//in main or wherever, beginning of execution
	ExitThread t = new ExitThread();
	//don't call t.start(), the hook will do it on exit
	addShutdownHook(t);
	Haven't tested it, but that should get you going. Also, you don't have to use the default constructor if you want to pass some params to that thread.


Gestione inizio della partita:

	//TODO

	//GIA IMPLEMENTATO

Primo turno:

	//TODO

	//GIA IMPLEMENTATO

Restanti turni:

	//TODO

	//GIA IMPLEMENTATO

Calcolo dei punti:

	//TODO

	//GIA IMPLEMENTATO

Termine della partita: (mortalPath)

	//TODO

	//GIA IMPLEMENTATO

-----------------------------------------------------------------------------------------------------------------------------------

        29 maggio 2019:

TODO DI OGGI: in ordine di importanza

1.  GESTIONE DEI TURNI:

Idea: 	un client può sempre mandare richiese ma se non è il suo turno non può fare nulla
		CASO PARTICOLARE:  	primo turno, il primo giocatore che si connette (ID = 0)  deve scegliere la mappa su cui giocare
							tutti i giocatori a primo turno devono scegliere dovre spawnare.
							NB : questa azione dello spawn viene ripetuta ogni volta che un giocatore muore.

	- gestione della fase iniziale della partita in stato: LOBBY / LOBBY_MASTER
		Thread lato server che gira e controlla il numero di giocatori connessi:
		finche sono < 3 tutto ok
		quando arrivo a 3 faccio scattare timer (da impostare parametrico su file di properties)
		quando scade timer oppure raggiungo 5 giocatori connessi inizio la partita:
			INIZIO DELLA PARTITA cosa significa:
			- modificare lo stato dei giocatori nel modo corretto e dare il potere al primo di scegliere le sue cose.

	- gestione del turno normale
		- impementare controlli sul turno prima di ogni azione e lanciare eccezioni
		- implementare metodi per cambio del turno dopo ogni azione (azione fondamentale, leggere regole)
		- gestione dei punteggi ?

	NICE TO HAVE: 	lato GUI ogni volta che cambia lo stato del giocatore mostrarlo aggiornato in un riquadretto
					in particolare quando diventa il mio turno facciamo illuminare qualcosa!

2.  comunicazione server-client con handshake RMI (vedi appunti AppuntiClient sul progetto)

3.  capire funzionamento degli observer over network (per aggiornare il modello lato client ogni volta che viene modificato lato server)

4.  sincronizzazione dei metodi per accesso concorrente efficace


STATO ATTUALE INSIEME DEGLI STATI POSSIBILI PER UN GIOCATORE:

public enum RoundStatus implements Serializable{
    LOBBY,			//il gicoatore si trova nella lobby in attesa che si connettano altri giocatori
    LOBBY_MASTER,	//il giocatore è nella lobby in attesa, è il PRIMO che si è connesso
    MASTER,			// master è il giocatore che sceglie la mappa della partita, è per forza il lobby master
    WAIT_TURN,		// attesa del proprio turno, in questo stato i permessi sono limitatissimi (solo uso della tagback grenade)
    FIRST_ACTION,	// il giocatore deve eseguire la prima azione
    SECOND_ACTION, 	// il giocatore deve eseguire la seconda azione
    RELOADING,		// il giocatore ha terminato la sua seconda azione e deve ricaricare le armi (se può); //TODO chiedere a riccky di implementare ill metodo per 					il reload delle armi da esporre sul matchController.
    END_TURN,		// serve per sapere che il giocatore ha finito il turno, centra con quello che diceva ricky sulla gestione dei punti e dei morti !!
    DISCONNECTED	// stato in cui il giocatore si è disconnesso dal server, significa che ha iniziato la partita ma ha staccato, può riconnettersi con lo stesso 						Nickname ed essere messo in waitTurn
}
